
#ifndef TOK
#define TOK(t)
#endif

#ifndef KEYWORD
#define KEYWORD(name) TOK(tok_##name)
#endif

#ifndef PUNCTUATOR
#define PUNCTUATOR(spelling, symbol) TOK(spelling)
#endif

#ifndef TYPE_MODIFIER
#define TYPE_MODIFIER(name) KEYWORD(name)
#endif

#ifndef FUNDAMENTAL_TYPE
#define FUNDAMENTAL_TYPE(name) KEYWORD(name)
#endif

#ifndef TYPE_QUALIFIER
#define TYPE_QUALIFIER(name) KEYWORD(name)
#endif

// The 0 value. To be used as a sentinel value
TOK(not_really_a_token)
TOK(eof)
TOK(unknown)
TOK(linecomment)
TOK(multilinecomment)
TOK(identifier)

TOK(integral_constant) // Whose type will be unsigned long long int

TOK(real_constant) // Whose type will be long double

TYPE_MODIFIER(long)
TYPE_MODIFIER(short)
TYPE_MODIFIER(signed)
TYPE_MODIFIER(unsigned)

FUNDAMENTAL_TYPE(int)
FUNDAMENTAL_TYPE(char)
FUNDAMENTAL_TYPE(void)
FUNDAMENTAL_TYPE(bool)
FUNDAMENTAL_TYPE(float)
FUNDAMENTAL_TYPE(double)

TYPE_QUALIFIER(const)

TOK(char_literal) // Whose type will be char

/// Malformed constant tokens are constants that have some sort of invalid
/// character within that we can't surely tell if it's supposed to be a part of
/// another constant or not The lexer will try to parse the constant all the way
/// to the point where the rogue characters show up and will continue to eat all
/// rogue characters that show up until it becomes obvious that the constant is
/// fully lexed.

/// A Malformed dotchain is a continuous sequence of dots whose length is
/// neither 1 or 3 (which are the dot and ellipsis tokens). Eg: .. ....
/// ............
TOK(malformed_dotchain)

TOK(string_literal) // Whose type will be either char* or a string type that
                    // contains length information

KEYWORD(while)
KEYWORD(for)
KEYWORD(switch)

KEYWORD(break)
KEYWORD(continue)

KEYWORD(if)
KEYWORD(else)

KEYWORD(class)
KEYWORD(enum)
KEYWORD(def)
KEYWORD(namespace)
KEYWORD(struct)
KEYWORD(union)
KEYWORD(mixin)
KEYWORD(macro)

KEYWORD(return )
KEYWORD(wait)
KEYWORD(yield)

KEYWORD(let)

KEYWORD(extern)

PUNCTUATOR(l_square, "[")
PUNCTUATOR(r_square, "]")
PUNCTUATOR(l_paren, "(")
PUNCTUATOR(r_paren, ")")
PUNCTUATOR(l_brace, "{")
PUNCTUATOR(r_brace, "}")
PUNCTUATOR(period, ".")
PUNCTUATOR(ellipsis, "...")
PUNCTUATOR(amp, "&")
PUNCTUATOR(ampamp, "&&")
PUNCTUATOR(ampequal, "&=")
PUNCTUATOR(star, "*")
PUNCTUATOR(starequal, "*=")
PUNCTUATOR(plus, "+")
PUNCTUATOR(plusplus, "++")
PUNCTUATOR(plusequal, "+=")
PUNCTUATOR(minus, "-")
PUNCTUATOR(arrow, "->")
PUNCTUATOR(minusminus, "--")
PUNCTUATOR(minusequal, "-=")
PUNCTUATOR(tilde, "~")
PUNCTUATOR(exclaim, "!")
PUNCTUATOR(exclaimequal, "!=")
PUNCTUATOR(slash, "/")
PUNCTUATOR(slashequal, "/=")
PUNCTUATOR(percent, "%")
PUNCTUATOR(percentequal, "%=")
PUNCTUATOR(less, "<")
PUNCTUATOR(lessless, "<<")
PUNCTUATOR(lessequal, "<=")
PUNCTUATOR(lesslessequal, "<<=")
PUNCTUATOR(spaceship, "<=>")
PUNCTUATOR(greater, ">")
PUNCTUATOR(greatergreater, ">>")
PUNCTUATOR(greaterequal, ">=")
PUNCTUATOR(greatergreaterequal, ">>=")
PUNCTUATOR(caret, "^")
PUNCTUATOR(caretequal, "^=")
PUNCTUATOR(pipe, "|")
PUNCTUATOR(pipepipe, "||")
PUNCTUATOR(pipeequal, "|=")
PUNCTUATOR(colonequal, ":=")
PUNCTUATOR(question, "?")
PUNCTUATOR(colon, ":")
PUNCTUATOR(semicolon, ";")
PUNCTUATOR(equal, "=")
PUNCTUATOR(equalequal, "==")
PUNCTUATOR(comma, ",")
PUNCTUATOR(hash, "#")
PUNCTUATOR(hashhash, "##")
PUNCTUATOR(hashat, "#@")

PUNCTUATOR(periodstar, ".*")
PUNCTUATOR(arrowstar, "->*")
PUNCTUATOR(coloncolon, "::")

PUNCTUATOR(at, "@")

PUNCTUATOR(lesslessless, "<<<")
PUNCTUATOR(greatergreatergreater, ">>>")

PUNCTUATOR(caretcaret, "^^")

#undef PUNCTUATOR
#undef KEYWORD
#undef TOK
#undef TYPE_MODIFIER
#undef FUNDAMENTAL_TYPE
#undef TYPE_QUALIFIER